#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

// **************************************** strlen ****************************************
//实现strlen的三种方法
//1、计数器
int my_strlen1(const char *str){
    assert(str!=NULL);
    int count=0;
    while(*(str+count)){
        count++;
    }
    return count;
}
//2、递归
int my_strlen2(const char *str){
    assert(str!=NULL);
    if(*str !='\0'){
        return 1+my_strlen2(str+1);
    }
}
//3、指针-指针
int my_strlen3(const char *head,int size){
    assert(head!=NULL);
    return (head+size-1)-head;
}

// int main(){
//     char arr[] = "abcdefg";
//     int size = sizeof(arr);
//     int len = strlen(arr);
//     printf("%d\n",len);//7
//     printf("%d\n",my_strlen1(arr));//7
//     printf("%d\n",my_strlen2(arr));//7
//     printf("%d\n",my_strlen3(arr,size));//7
//     // int arr[] = {'a','b','c','d','d','f'};
//     // int len = strlen(arr);
//     // printf("%d\n",len);//随机值
//     return 0;
// }

// int main(){
//     //size_t strlen(const char* str);
//     //库函数中的strlen返回值为      size_t == unsigned int
//     if( strlen("abc") - strlen("abcdef") > 0){
//         printf("hehe\n");
//     }
//     else {
//         printf("haha\n");
//     }
//     return 0;
// }

// **************************************** strlen ****************************************
//char *strcpy(char *destination,const char *source);
//源字符串必须以'\0'结束，会将源字符串的'\0'拷贝到目标空间
//目标空间必须足够大，目标空间必须可以修改
char *my_strcpy(char *dest,const char *src){
    assert(dest!=NULL);
    assert(src!=NULL);
    char *ret = dest;
    //拷贝src指向的字符串到dest指向的空间,包含'\0'
    while(*dest++ = *src++);
    //返回目的空间的起始地址
    return ret;
}
// int main(){
//     char arr1[] = "HelloWorld";
//     char arr2[] = "world";
//     // strcpy(arr1,arr2);   
//     // printf("%s\n",arr1);
//     char *ret = my_strcpy(arr1,arr2);
//     printf("%s\n",ret);
//     return 0;
// }

// **************************************** strcat ****************************************
//char *strcat(char *destination,const char *source);
//源字符串、目的地字符串都必须有'\0'
//目标空间必须足够大，能够容纳下源字符串的内容
//目标空间必须可以修改
char *my_strcat(char *dest,const char *src){
    assert(dest && src);
    char *ret = dest;
    while(*dest){
        dest++;
    };
    while(*dest++ = *src++);
    return ret;
}
// int main(){
//     char arr1[30] = "Hello\0xxxxxxxx";
//     char arr2[] = "world";
//     // strcat(arr1,arr2);
//     // printf("%s\n",arr1);
//     char *ret = my_strcat(arr1,arr2);
//     printf("%s\n",arr1);
//     return 0;
// }

// **************************************** strcmp ****************************************
//int strcmp(const char *string1,const char *string2);
int my_strcmp(const char *string1,const char *string2){
    assert(string1 && string2);
    int ret = 0;
    while(*string1 == *string2 ){
        if(*string1 =='\0'){
            return 0;   //相等
        }
        string1++;
        string2++;
    }; 
    if( *string1 > *string2) return 1;//大于
    else return -1;//小于
    return ret;
}
// int main(){
//     char *p1 = "abcdefg";
//     char *p2 = "aqwer"; 
//     // int ret = strcmp(p1,p2);
//     // printf("%d\n",ret);
//     int ret = my_strcmp(p1,p2);
//     printf("%d\n",ret);
//     return 0;
// }

// *********************************** strcpy & strncpy ***********************************
// char *strcpy(char *strDestination,const char *strSource);
// strcpy 不受字符串长度的限制，存在安全问题
// char *strncpy(char *strDest,const char *strSource,size_t count);
// count > strSource的长度时,会在后面接着补上 (count-strSource的长度) 个 '\0'
char *my_strncpy(char *dest,const char*source,int count){
    assert(dest && source);
    assert(count>=0);
    char *ret = dest;
    int i = 0;
    while(i<count){
        if(*source == '\0'){
            *dest = '\0';
        }
        else{
            *dest = *source;
            source++;
        }
        dest++;
        i++;
    }
    return ret;
}
// int main(){
//     char arr1[10] = "abcdef";
//     char arr2[] = "Hello world";
//     strncpy(arr1,arr2,4);
//     printf("arr1 = %s\n",arr1);
//     char arr3[10] = "abcdefgh";
//     char arr4[] = "bit";
//     strncpy(arr3,arr4,6);//长度不够时自动补充'\0' 
//     printf("arr3 =  %s\n",arr3);//bit\0\0\0gh
//     // test my_strncpy
//     char test_arr1[10] = "abcdef";
//     char test_arr2[] = "Hello world";
//     char *test_ret1 = my_strncpy(test_arr1, test_arr2, 4);
//     printf("test_arr2 = %s\n",test_arr1);
//     printf("test_ret1 = %s\n",test_ret1);
//     char test_arr3[10] = "abcdefgh";
//     char test_arr4[] = "bit";
//     char *test_ret2 = my_strncpy(test_arr3,test_arr4,6);
//     printf("test_arr3 = %s\n",test_arr3);
//     printf("test_ret2 = %s\n",test_ret2);
//     return 0;
// }

//**************************************** strncat ****************************************
// char *strncat(char *strDest,const char *strSource,size_t count);
// count > strSource时,会在追加字符串后在后面补上 一个 '\0'
char *my_strncat(char *dest,const char *src,int count){
    assert(dest && src);
    assert(count>=0);
    char *ret = dest;
    while(*dest){
        dest++;
    }
    while( count && src ){
        *dest++ = *src++;
        count--;
    }
    *dest = '\0';
    return ret;
}
// int main(){

